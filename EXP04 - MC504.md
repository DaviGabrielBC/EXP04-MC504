>Booting Up

cd 'Área de Trabalho'/UNICAMP/2024.2/MC504/EXP04/xv6
sudo su
docker build -t xv6 .
docker run -it xv6
ls

> Removing dangling docker images

docker images -q --filter "dangling=true" | xargs -r docker rmi -f

>kernel/riscv.h: r_time() counts cycles in machine-mode

>kernel/param.h: contém NPROC o máximo número de processos que pode rodar, talvez tentar aumentar esse limite? esse arquivo também contém NCPU

>Latencia eh o tempo que demora entre a solicitacao de uma operacao I/O e sua conclusao
>uint64 start_io = ticks; // Execução da operação de escrita 
>uint64 end_io = ticks; 
>io_latency += (end_io - start_io); 
>io_count++;
>t_lat = io_latency/io_count;


>*PROTECT SHARED VARIABLES -> Locks


>FileSystem Efficiency

fs_efficiency = (fs_read_time / fs_read_count) +
                (fs_write_time / fs_write_count) +
                (fs_unlink_time / fs_unlink_count);

normalized_efficiency = 1 - (fs_efficiency - fs_min) / (fs_max - fs_min);

uint64 avg_read_time = fs_read_time / fs_read_count;
uint64 avg_write_time = fs_write_time / fs_write_count;
uint64 avg_unlink_time = fs_unlink_time / fs_unlink_count;

norm_fs_efficiency = 1/(avg_read_time + avg_write_time + avg_unlink_time)

>Memory Management Overhead Efficiency

uint64 avg_access_time = mem_access_time / mem_access_count;
uint64 avg_alloc_time = mem_alloc_time / mem_alloc_count;
uint64 avg_free_time = mem_free_time / mem_free_count;

norm_mem_effeciency = 1/(avg_access_time + avg_alloc_time + avg_free_time);


>**Etapa 3: Otimizações**

- **Escalonador:** Desenvolva um novo algoritmo.
- **I/O:** Implemente cache ou ajuste o buffer.
- **Sistema de Arquivos:** Reduza a latência média de operações comuns.
- **Gerenciamento de Memória:** Acelere alocações e substituições.

### 4. **Relatório Final**

O relatório deve conter:

1. **Introdução:**
    - Objetivo do projeto e contexto.
2. **Metodologia:**
    - Como foram feitas as medições e simulações.
    - Descrição das otimizações implementadas.
3. **Resultados:**
    - Tabelas e gráficos comparando métricas antes e depois.
    - Desempenho geral (fórmula final).
4. **Discussão:**
    - Limitações das abordagens utilizadas.
    - Propostas para melhorias futuras.
5. **Conclusão:**
    - Resumo do impacto das otimizações.

### 5. **Recursos Úteis**

- **Documentação do xv6:** MIT xv6 Book
- **Dijkstra Implementation:** Use uma biblioteca simples em C ou desenvolva do zero.
- **Gerador de Grafos Aleatórios:** Pode usar um algoritmo básico para gerar grafos orientados.



> Docker troubleshooting part 1
 
docker ps -a
docker inspect <container-id>
docker run -it -v "/mnt/c/Users/davib/Área de Trabalho/UNICAMP/2024.2/MC504/EXP04/xv6-riscv-riscv:/xv6-riscv" xv6-riscv
(tentar mover para diretório sem o ´ foi uma idea do gpt)

kernel/main.c
kernel/riscv.h
kernel/sysproc.c
kernel/syscall.h
kernel/syscall.c
user/sh.c
kernel/proc.c
mkfs/mkfs.c
user/init.c
/Makefile
kernel/console.c